'''todo 

constrained fit with all params fitted simutaneously


'''

import sys
sys.path.append('..')
import coordmagic as cm
import numpy as np
import os
import glob
from collections import defaultdict
import parmed as pmd
import matplotlib.pyplot as pyplot
class TorsionFit:
    def __init__(self,paramrefine,bond,angle="e5,360,0",period='auto',
                 eth=100,opt='no',gjf='',regen='',ar='',nd='', kth=0.02,ene=''):
        self.basename = paramrefine.basename
        self.bond = bond
        self.period=period
        self.ene = ene # ground or excited state energy to read
        if angle.startswith('e'):
            p = angle.strip('e').split(',')
            if len(p) == 1:
                p = p+[360] + [0]
            elif len(p) == 2:
                p = p + [0]
            elif len(p) > 3:
                p = p[:3]
            angle_list = list(np.arange(float(p[2]),float(p[1])+1,float(p[0])))
        else:
            angle_list = [float(i) for i in angle.split()]
        self.angle_list = angle_list
        self.wkdir = '_'.join([self.basename,'DFit',self.bond])
        self.xyz_flnm = self.wkdir + '.xyz'
        self.fig_flnm = self.wkdir + '.png'
        paramrefine.adj_dihedral(contract='none')
        self.ps = paramrefine.ps
        self.st = cm.conver_structure(self.ps, 'parmed')
        self.st.G.gen_mol()
        # print(self.st.molecules[2])
        if len(self.st.molecules) > 1:
            print('Error!!! More than one molecule detected in the input file')
            sys.exit()
        self.G = self.st.molecules[1]['graph']
        self.max_periodicity = max([self.G.degree(int(i))-1 for i in self.bond.split('-')])
        self.scee = self.ps.dihedral_types[0].scee
        self.scnb = self.ps.dihedral_types[0].scnb
        self.get_dihedrals()
        if period.lower() == 'auto':
            period = self.auto_period
        self.gjf_options = defaultdict(str, {v.split(':')[0]: v.split(':')[1]
                                             for v in gjf.split(';') if ':' in v})
        self.opt = opt
        self.regen = regen
        if self.regen == 'gjf':
            self.prep_inp()
            sys.exit()
        self.read_xyz(threshold=float(eth))
        self.measure_dihedrals()
        if ar:
            self.filter_by_angles(angle_range=ar)
        self.fit_least_square(period=period,nd=nd,kth=float(kth))
        # paramrefine.adj_dihedral(contract='auto')

    def read_xyz(self,threshold=60):
        '''read xyz file generated by  self.gen_xyz
        get the self.coords and self.ref_energies
        '''
        if self.regen == 'xyz':
            self.gen_xyz()
        try:
            f = open(self.xyz_flnm)
        except FileNotFoundError:
            self.gen_xyz()
        st=cm.read_structure(self.xyz_flnm)
        coords = []
        energies = []
        for struct in st.frames:
            coords.append(struct.coord)
            energies.append(float(struct.prop['comment'].split()[0]))
        ref_energies = np.array(energies) - np.min(energies)
        filtered_ene = []
        filtered_coord = []
        for i,e in enumerate(ref_energies):
            min_e = min(ref_energies)
            if e-min_e <= threshold:
                filtered_ene.append(e)
                filtered_coord.append(coords[i])

        self.coords=np.array(filtered_coord) / 10
        self.ref_energies = filtered_ene
        print("{:s} read sucessfully, {:d} structures and energies readed, {:d} left after filtered"
              .format(self.xyz_flnm,len(energies),len(self.ref_energies)))

    def prep_inp(self):
        '''prepare directory and input file for calculation'''
        # make directory
        # check if gjf file exists
        # if not exists generate one
        # generate structure
        # generate gaussian input
        headtail_param = {'chk': "", 'nproc': '8', 'mem': '4GB', 'extra': ''}
        kw_param = {'method': 'b3lyp', 'basis': 'def2svp', 'solvent': 'water', 
                    'addkey': '', 'vdw': 'em(gd3bj)'}
        sc_param = {'spin': "1", 'charge': "0"}
        headtail_param.update({k: v for k, v in self.gjf_options.items() if k in headtail_param.keys()})
        kw_param.update({k: v for k, v in self.gjf_options.items() if k in kw_param.keys()})
        sc_param.update({k: v for k, v in self.gjf_options.items() if k in sc_param.keys()})
        gas_kw = ' '.join([kw_param['method'], kw_param['basis'], kw_param['vdw'], kw_param['addkey']])
        extra = self.gjf_options['extra'].encode('utf-8').decode('unicode-escape') + "\n" 
        if kw_param['solvent'] and kw_param['solvent'] != 'none':
            sol_kw = gas_kw + 'scrf(pcm,solvent={:s})'.format(kw_param['solvent'])
        else:
            sol_kw = gas_kw
        if self.opt == "fixone":
            extra = "D "+" ".join([str(i) for i in self.dihedrals[0][0]])+" F\n" +"\n"+ extra
            sol_kw = 'opt(modredundant) ' + sol_kw
        elif self.opt == "fixall":
            fixcoord = ""
            sol_kw = 'opt(modredundant) ' + sol_kw
            for d in self.dihedrals:
                fixcoord += "D " + " ".join([str(i) for i in d[0]]) + " F\n"
            extra = fixcoord + "\n" + extra
        combined_param = {}
        combined_param.update(headtail_param)
        combined_param.update(sc_param)
        combined_param['keywords'] = sol_kw
        combined_param['extra'] = extra
        try:
            os.mkdir(self.wkdir)
        except FileExistsError:
            pass
        cwd = os.getcwd()
        os.chdir(self.wkdir)
        exit_flag = 0
        for a in self.angle_list:
            angle_str="{:06.2f}".format(a)
            flnm = self.basename+'_'+angle_str+'.gjf'
            chknm = self.basename+'_'+angle_str+'.chk'
            combined_param['chk'] = chknm
            if self.regen == 'gjf':
                g = cm.rotate_mol_dihedral(self.G,self.bond,a)
                cm.write_structure(g, name=flnm, **combined_param)
                exit_flag = 1
            try:
                f = open(flnm)
            except FileNotFoundError:
                g = cm.rotate_mol_dihedral(self.G,self.bond,a)
                cm.write_structure(g,name=flnm, **combined_param)
                exit_flag = 1
            else:
                f.close()
        if exit_flag == 1:
            print("gjf file generate complete in {:s}, you need to compute these files by youself"
                  .format(self.wkdir))
            sys.exit()
        os.chdir(cwd)

    def gen_xyz(self):
        '''check if log file of gaussian are available and terminated normally
        if not enough < 6 normal terminated log file is available, report error and exit
        else  generate a xyz file with coords and energies in it
        '''
        logs = os.path.join(self.wkdir,self.basename+'_'+'*.log')
        logfiles = sorted(glob.glob(logs))
        log_check = {}
        for log in logfiles:
            log_check[log] = 0
            f = open(log,"r")
            for l in f:
                if "Normal termination" in l:
                    log_check[log] = 1
        norm_log = len([v for k,v in log_check.items() if v == 1])
        all_log = len(logfiles)
        print('{:d}/{:d} log file ternimate Normally'.format(norm_log,all_log))
        if norm_log < 6:
            print('Error! not enough Normal terminated log files in {:s}'.format(self.wkdir))
            self.prep_inp()
            sys.exit()
        idx = 0
        for log in logfiles:
            st=cm.read_structure(log)
            if st:
                if st.prop["ex_energy"] and (not self.ene or self.ene=='ex'):
                    ene = st.prop["ex_energy"]
                elif st.prop["energy"] and (self.ene=='g' or not self.ene):
                    ene = st.prop["energy"]
                elif not st.prop["energy"] and not st.prop["ex_energy"]:
                    print('Error! could not find ground or excited state energy from gaussian log file')
                    sys.exit()
                else:
                    print('Error! options ene={:s} is not right.\n'
                          'Available options are g or ex(only if excited state energies are available)'.format(self.ene))
                    sys.exit()
                comment = '{:.6f}'.format(ene * 2625.5) + ' kJ/mol'
                if idx == 0:
                    st.save(self.xyz_flnm,frame='last',append=False,comment=comment)
                else:
                    st.save(self.xyz_flnm,frame='last',append=True,comment=comment)
            idx = idx + 1

    def calc_score(self, sn):
        '''calculate score of a atom
        given the seirial number (sn, not index) of that atom
        '''
        if self.G.degree(sn) <= 2:
            score =  self.G.nodes[sn]['atomnum']
        else:
            score = self.G.degree[sn] * 100
            score += sum([self.G.degree[i] * 10  for i in self.G.adj[sn]])
            score += self.G.nodes[sn]['atomnum']
        return score

    def get_dihedrals(self):
        ''' get dihedrals and sorted by their priority
        the priority is determined by atom 1 and atom 4
        and use self.calc_score to calulate the score
        the high priority dihedrals will be fitted first
         '''
        a1,a2 = [int(i)-1 for i in self.bond.split('-')]
        pmd_dihedrals = defaultdict(list)
        for d in self.ps.dihedrals:
            if d.atom2.idx == a1 and d.atom3.idx == a2 or \
                    d.atom3.idx == a1 and d.atom2.idx == a2:
                if not d.improper:
                    pmd_dihedrals[(d.atom1.idx+1,d.atom2.idx+1,d.atom3.idx+1,d.atom4.idx+1)].append(d)
        b = a1 + 1
        c = a2 + 1
        dihedrals = {}
        auto_period = ','.join(list(set([str(len(self.G.adj[b])-1),str(len(self.G.adj[c])-1)])))
        for a in self.G.adj[b]:
            for d in self.G.adj[c]:
                if a != c and b != d:
                    dihed_sn = (a,b,c,d)
                    dihed_elem = [self.G.nodes[i]['elem'] for i in dihed_sn]
                    dihed_score = self.calc_score(a)+self.calc_score(d)
                    dihedrals[dihed_sn] = defaultdict(str,{'score':dihed_score,'elem':dihed_elem})
        reverse_sn = []
        for k,v in dihedrals.items():
            if k in pmd_dihedrals:
                for d in pmd_dihedrals[k]:
                    # if type(d.type) is pmd.DihedralTypeList:
                    phi_k = d.type.phi_k
                    per = d.type.per
                    phase = d.type.phase
                    key = 'k'+str(per)
                    v[key]=(phi_k,phase)
            if k[::-1] in pmd_dihedrals:
                reverse_sn.append(k)
                for d in pmd_dihedrals[k[::-1]]:
                    phi_k = d.type.phi_k
                    per = d.type.per
                    phase = d.type.phase
                    key = 'k' + str(per)
                    v[key] = (phi_k, phase)
        for k in reverse_sn:
            dihedrals[k[::-1]] = dihedrals[k]
            del dihedrals[k]
        dihedrals=sorted([(k,v) for k,v in dihedrals.items()],key=lambda x:x[1]['score'],reverse=True)
        self.dihedrals = dihedrals
        self.pmd_dihedrals = pmd_dihedrals
        self.auto_period = auto_period


    def report_dihedrals(self):
        '''report dihedrals in self.dihedrals'''
        for d in self.dihedrals:
            dihedral_str = '-'.join([str(i[0])+i[1] for i  in zip(d[0],d[1]['elem'])])
            param_str = []
            for i in '1,2,3,4,5,6,7,8,9'.split(','):
                k = 'k'+i
                if len(d[1][k]) > 0:
                    param_str.append(k+'='+ '{:.2f},{:.1f}'.format(*d[1][k])+';')
            all_p = ''.join(['{:16s}'.format(i) for i in param_str])
            print('{:24s}  {:<s}'.format(dihedral_str,all_p))

    def add_torsion(self, sn, k, n, ign=True):
        '''if a term with ignore_end=False is added
        then the origin torsion term with phi_k = 0 is removed'''
        a1,a2,a3,a4 = [self.ps.atoms[i-1] for i in sn]
        if int(n) % 2 == 0:
            phase = 180
        else:
            phase = 0
        # when add a torsion, first found a torsion  same period to
        # the adding torsion. Then remove that torsion and pass its ignore_end properties to the adding torsion
        self.get_dihedrals()
        for d in self.pmd_dihedrals[sn]:
            if d.type.per == n:
                ign = d.ignore_end
                self.ps.dihedrals.remove(d)
        new_type = pmd.DihedralType(k, n, phase, scee=self.scee, scnb=self.scnb, list=self.ps.dihedral_types)
        self.ps.dihedral_types.append(new_type)
        new_d = pmd.Dihedral(a1, a2, a3, a4, improper=False, ignore_end=ign, type=new_type)
        # print(new_d)
        self.ps.dihedrals.append(new_d)
        self.get_dihedrals()
        # print(self.pmd_dihedrals[(48,27,35,34)])
        # print(self.dihedrals)

    def measure_dihedrals(self):
        '''measure all dihedrals in self.coords
        the dihedrals to measure is designate in self.dihedrals
        this will generate a n * m self.angles
        where n is the length of self.coords and
        m is the length of self.dihedrals'''
        def calc_dihedral(coord):
            p0, p1, p2, p3 = coord
            b0 = -1.0 * (p1 - p0)
            b1 = p2 - p1
            b2 = p3 - p2
            b1 /= np.linalg.norm(b1)
            v = b0 - np.dot(b0, b1) * b1
            w = b2 - np.dot(b2, b1) * b1
            x = np.dot(v, w)
            y = np.dot(np.cross(b1, v), w)
            return np.degrees(np.arctan2(y, x))
        da = defaultdict(list)
        for c in self.coords:
            for sn,v in self.dihedrals:
                coord = [c[i-1] for i in sn]
                angle = calc_dihedral(coord)
                da[sn].append(angle)
        self.angles = da

    def filter_by_angles(self,angle_range):
        '''specify angle_rangle to filter the data
        the angle in angle_range will be fitted
        this will update self.angles and self.coords  and self.ref_energies
        '''
        angles = []
        coords = []
        ref_ene = []
        ar_list = []
        for ar in angle_range.split(','):
            a1,a2 = [float(i) for i in ar.split('~')]
            if a1 > a2:
                ar_list.append((a2,a1))
            else:
                ar_list.append((a1, a2))
        angles_1 = list(self.angles.items())[0][1]
        keep_idx = []
        for i,a in enumerate(angles_1):
            for ar in ar_list:
                if a >= ar[0]  and a <= ar[1]:
                    keep_idx.append(i)
        angles = {k:[v[i] for i in keep_idx] for k,v in self.angles.items()}
        coords = [self.coords[i] for i in keep_idx]
        ref_ene = [self.ref_energies[i] for i in keep_idx]
        self.coords = coords
        self.ref_energies = ref_ene
        self.angles = angles



    def evalulate_ene(self):
        '''evalueate openmm energy of coords in self.coords
        and return a tuple of mm_ene and diff_ene
        the mm_ene is a list of energys with same length to coords
        the mm_ene is a relative energy to it's first values
        the diff_ene is the energy difference between self.ref_energy and mm_ene
        '''
        import openmm as mm
        import openmm.app as app
        from openmm.unit import kelvin, picoseconds, femtoseconds, nanometer
        integrator = mm.LangevinIntegrator(
            300 * kelvin,  # Temperature of heat bath
            1.0 / picoseconds,  # Friction coefficient
            2.0 * femtoseconds,  # Time step
        )
        try:
            if self.ps.box is not None:
                system = self.ps.createSystem(nonbondedMethod=app.PME, constraints=app.HBonds, nonbondedCutoff=1*nanometer)
            else:
                system = self.ps.createSystem(nonbondedMethod=app.NoCutoff, constraints=app.HBonds)
            sim = app.Simulation(self.ps.topology, system, integrator)
        except:
            self.ps.save('tempforopenmm.prmtop',overwrite=True)
            prmtop = app.AmberPrmtopFile('tempforopenmm.prmtop')
            if self.ps.box is not None:
                system = prmtop.createSystem(nonbondedMethod=app.PME, constraints=app.HBonds, nonbondedCutoff=1*nanometer)
            else:
                system = prmtop.createSystem(nonbondedMethod=app.NoCutoff, constraints=app.HBonds)
            sim = app.Simulation(prmtop.topology, system, integrator)
            os.remove('tempforopenmm.prmtop')
        # Create the integrator to do Langevin dynamics
        # Set the particle positions
        if self.ps.box is not None:
            sim.context.setPeriodicBoxVectors(*self.ps.box_vectors)
        # Create the integrator to do Langevin dynamics
        # Set the particle positions
        energies=[]
        for i,c in enumerate(self.coords):
            sim.context.setPositions(c)
            # sim.minimizeEnergy(tolerance=1)
            state = sim.context.getState(getEnergy=True)
            energies.append(state.getPotentialEnergy().reduce_unit())
        # print(energies)
        mm_ene = np.array([i._value for i in np.array(energies)])
        mm_ene = mm_ene - np.min(mm_ene)
        diff_ene = self.ref_energies - mm_ene
        return (mm_ene,diff_ene)

    def fit_k_only(self,diff_ene, period='',nd=[],kth=0.00):
        # use dict_k to store fitted k and to update k in each iteration
        # sstoto is used to calculat R
        sstot = diff_ene.size * diff_ene.var()
        dict_k = defaultdict(int)
        for nds in nd:
            # select dihedral to participate the fitting
            dihed_group = [self.dihedrals[i] for i in nds]
            # print('Fitting torsion constant using {:s} dihedrals...'.format(','.join([str(i) for i in nd[:i+1]])))
            # clist is the coefficient list and the number of coeff is equal to the number of period
            clist = []
            for n in period:
                if int(n) % 2 == 0:
                    phase = 180
                else:
                    phase = 0
                alist = []
                for i,data in enumerate(dihed_group):
                    sn,v = data
                    angles = np.array(self.angles[sn])
                    alist.append(np.array(1+np.cos(np.deg2rad(angles*int(n)-phase))))
                a = np.column_stack(alist)
                clist.append(np.sum(a,axis=1))
            c = np.column_stack(clist)
            # elinimate linear depended columns
            q,r =np.linalg.qr(c)
            if any(np.abs(np.diag(r)) <= 0.05):
                print('Omit period {:s} due to linear dependancy'
                      .format(','.join([str(i+1) for i in (np.abs(np.diag(r)) <= 0.1).nonzero()[0]])))
            remain_period = np.array(period)[np.abs(np.diag(r)) > 0.05]
            x = c[:,np.abs(np.diag(r)) > 0.05]
            # add constant to formula
            # do the least square fitting
            k,residual = np.linalg.lstsq(x,diff_ene,rcond=None)[:2]
            r2 = 1 - residual[0]/sstot
            k = k/4.184
            # update dict_k and parameters by fitted k
            for j,phi_k in enumerate(k):
                for sn,v in dihed_group:
                    n = [int(i) for i in remain_period]
                    per = n[j]
                    if abs(phi_k) > kth:
                        dict_k[(sn,per)] += phi_k
                        self.add_torsion(sn,dict_k[(sn,per)],per)
            # evaluate energy
            mm_ene,diff_ene = self.evalulate_ene()
        return mm_ene,diff_ene,r2

    def fit_least_square(self, period='1,2,3,4',nd='',kth=0.00):
        '''use least square to fit torsion  param
        all the dihedrals have same k
        the periodicity is determined by the largest degree of the connecting atom
        the points with energy abouve threshold will be ignored
        '''
        def sortxy(x,y):
            '''sort x from small to big and y according to x's new order'''
            zipped = sorted(zip(x,y),key=lambda x:x[0])
            new_x,new_y = list(zip(*zipped))
            return new_x,new_y
        angles_1=list(self.angles.items())[0][1]
        print('Dihdral params fitted before:')
        mm_ene,diff_ene = self.evalulate_ene()
        mse = np.mean(diff_ene)
        rmse = np.mean(diff_ene**2)**0.5
        mae = np.mean(np.abs(diff_ene))
        print("RMSE:{:.3f}; MSE:{:.3f}; MAE:{:.3f} (unit:kJ/mol)".format(rmse,mse,mae))
        #draw qc energy curve
        fig, (ax1, ax2) = pyplot.subplots(1, 2)
        x,y = sortxy(angles_1,self.ref_energies)
        ax1.plot(x,y,label='QC energy')
        # choose proper xticks
        minmax_x = [x[np.argmin(y)],x[np.argmax(y)]]
        xtick_dict={(60,120):[-180,-120,-60,0,60,120,180],
                    (90,):[-180,-90,0,90,180],
                    (45,135):[-180,-135,-90,-45,0,45,90,135,180]}
        def calcsc(xtick,mmx):
            return min([min(np.abs(np.array(xtick) - abs(mmx[0]))),min(np.abs(np.array(xtick) - abs(mmx[1])))])
        min_sc = sorted([(calcsc(k,minmax_x),k) for k in xtick_dict],key=lambda x:x[0])[0][1]

        if min_sc in xtick_dict:
            xticks = xtick_dict[min_sc]
            xticks = [i for i in xticks if i>min(x)-10 and i<max(x)+10]
            ax1.set_xticks(xticks)
            ax2.set_xticks(xticks)
        # draw mm energy curve
        x,y = sortxy(angles_1,mm_ene)
        ax1.plot(x,y, '.-', label='Initial param ')
        ax1.set_xlabel('dihedral angle {:s}'.format('-'.join([str(i) for i in self.dihedrals[0][0]])))
        ax1.set_ylabel('kJ/mol')
        ax1.legend()
        self.report_dihedrals()
        self.measure_dihedrals()
        # set current constant to 0
        for sn,v in self.pmd_dihedrals.items():
            for d in v:
                new_type = pmd.DihedralType(0, d.type.per, d.type.phase, scee=self.scee,
                                            scnb=self.scnb, list=self.ps.dihedral_types)
                self.ps.dihedral_types.append(new_type)
                d.type = new_type
        mm_ene,diff_ene = self.evalulate_ene()
        # w = np.copy(diff_ene)
        # threshold = float(threshold)
        # w[w < threshold ] = 1
        # w[w > threshold ] = 0
        # set number of dihedrals to participate in the fitting
        # nd is a two dimensional list, the lengh should be from long to short
        if not nd:
            nd = [list(range(i+1)) for i in sorted(range(len(self.dihedrals)),reverse=True)]
        else:
            nds = []
            for i in nd.split(','):
                if '.' in i:
                    ds = [int(j)-1 for j in i.split('.') if j ]
                elif i.isdigit():
                    ds = [j for j in range(int(i))]
                else:
                    print('Error! nd parameter {:s} not recognized'.format(nd))
                    sys.exit()
                nds.append(ds)
            nd=nds
            # nd = sorted(nds,key=lambda x:len(x),reverse=True)

        period = period.split(',')
        # iterate over different numbers of dihedrals
        # first is 1,2,3,4 then 1,2,3 then 1,2 then 1
        # in each iteration the k of all the diherals will be equal
        mm_ene,diff_ene,r2=self.fit_k_only(diff_ene, period=period, nd=nd, kth=kth)
        # mm_ene,diff_ene,r2=self.fit_k_angle(diff_ene, period=period, nd=nd, kth=kth)
        x,y = sortxy(angles_1,self.ref_energies)
        ax2.plot(x, y, label='QC energy')
        x,y = sortxy(angles_1,mm_ene)
        ax2.plot(x, y, '.-', label='Fitted param ')
#         x,y = sortxy(angles_1,diff_ene)
#         ax2.plot(x, y, '.-', label='diff ')
        ax2.set_xlabel('dihedral angle {:s}'.format('-'.join([str(i) for i in self.dihedrals[0][0]])))
        ax2.set_ylabel('kJ/mol')
        ax2.legend()
        ax2.annotate('R2={:.5f}'.format(r2),xy=(0.02,0.95),xycoords='axes fraction')
        fig.savefig(self.fig_flnm, dpi=300)
        pyplot.show()
        self.get_dihedrals()
        print('Dihdral params fitted after:')
        mse = np.mean(diff_ene)
        rmse = np.mean(diff_ene**2)**0.5
        mae = np.mean(np.abs(diff_ene))
        print('R^2={:.6f}'.format(r2))
        print("RMSE:{:.3f}; MSE:{:.3f}; MAE:{:.3f} (unit:kJ/mol)".format(rmse,mse,mae))
        self.report_dihedrals()
        # print(self.dihedrals)
